# javascript_definitive_guide
The JavaScript Definitive Guide

## 자바스크립트 소개
- 객체지향 프로그래밍을 지원하는 인터프리터 방식의 프로그램이다.
- 변수의 타입을 명시할 필요가 없는 타입 제약이 약한 언어이다.
- 범용 프로그램 언어이므로 특별한 환경에서만 사용되지 않는다.
- 리터럴(literal)은 프로그램에 직접 나타나는 데이터 값이다.
- 식별자는 이름이다. 변수나 함수에 이름을 붙이거나 루프(loop) 문에 레이블을 붙이는데 사용된다.
---
## 데이터 타입과 값
- 프로그램 언어로 표현할 수 있고 조작할 수 있는 값의 종류를 데이터 타입이라고 한다.
- 세가지 기본 데이터 타으로는 숫자(number), 문자열(string), 진리 값(boolean)이 있다.
- 또한 두 개의 단순 데이터 타입인 null과 undefined를 정의한다.
- 이외에도 객체(object)라는 복합 데이터 타입을 지원한다.
- 객체는 이름 붙은 값들의 순서 없는 값들을 나타낸다.
- 번호가 붙은 순서 있는 값들의 모임을 배열(array)이라 한다.
### 숫자 (number)
- 정수 값과 실수 값을 구별하지 않고 모든 숫자는 실수로 표현한다.
- 산술연산자로는 +,-,*,/가 있다.
- 기본 산술연산자 이외에도 많은 수의 수리 함수를 사용해 복잡한 수리 연산을 수행할 수 있다.
- 0을 0으로 나누는 등 정의되지 않은 결과를 산출하거나 에러를 발생시킬 경우 특수한 값 NaN을 출력한다.
- NaN은 어떤 숫자와 비교해도 동일하지 않으며 심지어 NaN과 NaN을 비교해도 동일하지 않다.
### 문자열 (string)
- 문자열 리터럴은 한 줄을 넘지 말아야 하며, 줄바꿈(new line)을 포함시키고 싶다면 \n을 사용한다.
- 숫자를 문자열로 변홚나려면 빈 값을 더하거나(1 + ""), 명시적으로 변환하려면 String() 함수를 사용한다.
- 문자열 "120"을 숫자로 명시적으로 변환하려면 Number() 생성자를 함수처럼 호출한다.
### 불리언 값 (boolean)
- 오직 두개의 값만 가질 수 있다. (true, false)
- 일반적으로 비교의 결과로 생성된다. (제어 구조 내에서 사용)
- 명시적 타입변환은 Boolean() 함수를 사용할 수 있다.
### 함수 (function)
- 전달인자(agument), 매개변수(parameter)
- 함수가 어떤 객체의 프로퍼티로 할당되면 해당 객체의 메서드(method)라고 부른다.
- 일반적인 함수 정의 방법은 아래와 같다.
<pre><code>function foo(x){
    return x+x;
}</code></pre>
- 또한 아래와 같이 함수 리터럴 문법도 제공한다.
<pre><code>var foo = function(x){
    return x+x;
}</code></pre>
- 위와 같이 함수를 리터럴 형태로 포함시킬 수 있게 한 함수를 람다함수(lambda function)라 부른다.
### 객체 (object)
- 객체는 이름 붙은 값들의 모음이다. 보통 이 이름 붙은 값들을 객체의 프로퍼티(property)라고 부른다.
- 객체 프로퍼티를 참조하려면 아래와 같이 작성한다. (image라는 객체의 width프로퍼티를 참조)
<pre><code>var image = {
    "width":300
}
image.width; //300</code></pre>
- 객체의 프로퍼티는 배열, 함수, 객체 등 어떠한 타입의 값도 담을 수 있다.
- boolean 문에서 사용되면 'true'로 변환된다.
### 배열 (Array)
- 배열도 객체처럼 데이터 값들의 모음이지만, 데이터 값의 이름 대신 번호, 즉 인덱스(index)가 있다.
- 배열은 다른 배열이나 객체, 또는 함수를 포함한 어떤 데이터 타입의 데이터도 담을 수 있다.
- boolean 문에서 사용되면 'true'로 변환된다.
### null
- 아무런 값도 나타내지 않는 특수한 값이다.
- null은 보통 객체 타입의 특수한 값, 즉 어떠한 객체도 나타내지 않는 값으로 취급된다.
- 다른 모든 값들과 구분되는 고유한 값이다.
- boolean 문에서 사용되면 'false'로 변환된다.
### undefined
- null과는 구분되는 특수한 값이다.
- undefined는 선언이 되었지만 값이 할당되지 않은 변수, 존재하지 않는 객체 프로퍼티에 접근할 경우 반환되는 값이다.
- null과 undefined값은 서로 구별되는 값이지만 동등 연산자(==)는 둘을 같은 것으로 본다. **(undefined == null // true)**
- boolean 문에서 사용되면 'false'로, 숫자 문맥에서는 NaN, 문자열 문맥에서는 "undefined"로 변환된다.
### 값에 의한 vs 참조에 의한
- 데이터 타입 조작 요약 표

| 타입 | 복사  | 전달  | 비교  |
| ---- | ---- | ---- | ---- |
| 숫자  |  값  |  값  |  값  |
| 불리언 |  값  |  값  |  값  |
| 문자열 | 불변 | 불변  |  값  |
| 문자열 | 참조 | 참조 | 참조 |

---

## 변수
### 변수 타입
- 다른 프로그래밍 언어와 달리 타입이 고정되어 있지 않다.
### 가비지 컬렉션
- 자바스크립트 인터프리터는 어떤 객체가 어느 시점부터 프로그램에서 더이상 접근할 수 없다고 판명되면 해당 객체가 더이상 필요 없다 판단하여 할당했던 메모리를 해제하여 재활용 될 수 있게 한다.

---

## 표현식과 연산자
### 조건부 연산자 (?:)
- 유일한 3항 연산자 (피연산자가 3개)이다.
<pre><code>x > 0 ? x*y : x+y</code></pre>
- 첫 번째 피 연산자는 불리언 값 또는 불리언 값으로 변환될 수 있어야 한다.
- 첫번째 피 연산자의 값이 true이면 두 번쨰 피 연산자의 값이 된다. false이면 세 번째 피연산자의 값이 된다.
### typeof 연산자
- 단일 피연산자 앞에 위치하는 단항 연산자로, 이 연산자의 값은 피연산자의 데이터 타입을 가리키는 문자열이다.
- null값에 대해서는 "object"를 반환한다.
### delete 연산자
- 단항 연산자이며 피연산자로 지정된 객체의 프로퍼티, 배열의 원소 또는 변수의 삭제를 시도한다. 성공적으로 삭제되었을 경우에는 true를, 실패하였을 때는 false를 반환한다.
- 사용자가 var문으로 정의한 변수는 삭제할 수 없다.
- 존재하지 않는 프로퍼티에 대해 delete를 호출할 경우 true가 반환된다.
### 배열과 객체 접근 연산자
- 배열원소에 접근은 대괄호([])를 사용하며, 객체의 원소에 접근은 마침표(.)를 사용한다.
<pre><code>arr[0] //arr배열의 첫번재 원소에 접근
obj.name //obj객체의 name식별자(property)에 접근</code></pre>
- []와 . 모두 연산자로 취급된다.

## 문장
### switch
- if문은 프로그램이 실행되는 흐름에 분기(branch)를 일으킨다.
- 여러개의 if문(else if)을 사용해서 다중 분기를 수행할 수 있지만, 모든 분기가 단 하나의 변수 값에 의해 결정될 때에는 낭비이다. 이때 switch문을 사용하면 효율적이다.
<pre><code>switch(표현식){
    문장
}</code></pre>
- switch문이 실행되면 "표현식"의 값을 계산하고 이에 매칭되는 case 레이블을 찾고, 올바른 레이블을 찾으면 해당 case 코드블록을 실행한다. 만약 매칭되는 레이블이 없다면 default 레이블의 코드블록을 실행하며, defalut; 레이블도 없으면 모든 코드블록을 skip한다.
<pre><code>switch(n){
    case 1 :
        // n이 1이면 실행
        break;
    case 2 :
        // n이 2면 실행
        break;
    default :
        //모든 case에 해당하지 않는 경우 실행
}</code></pre>
- break문은 코드 실행을 중지하고 switch문이나 루프의 끝으로 건너뛰는 역할을 한다.
- 함수 내에서 switch문을 사용할 때는 break대신 return을 사용할 수도 있다.
- case문에서는 동등 연산자(==)가 아닌 일치 연산자(===)가 사용된다.
### while
- 기본적인 반복문. 표현식을 평가 후 그 값이 true이면 실행된 후, 다시 표현식을 평가한다. 표현식이 false가 될때까지 반복된다. false가 되면 while문이 종료된다.
<pre><code>while(표현식){
    문장
}</code></pre>
### do/while
- while문과 많은 점에서 비슷하다. 차이점은 루프 표현식이 루프의 처음이 아니라 마지막이다. 때문에 한 번은 루프의 몸체가 실행된다.
<pre><code>do{
    문장
}while(표현식);</code></pre>
### for
<pre><code>for(초기화; 평가; 증가(감)){
    문장
}</code></pre>
### for/in
<pre><code>for(변수 in 객체){
    문장
}</code></pre>
### 레이블
- switch문에서 쓰이는 case와 default; 레이블은 특별한 레이블 문이다.
<pre><code>parser:
    while(token != null){
    //문장
}</code></pre>
- 어떤 문장에 레이블을 붙이면 다른 곳에서 그 문장을 참조할 수 있는 이름이 생기는 셈이다. 레이블은 어떤 문장에라도 붙일 수 있지만 흔히 while, do/while, for, for/in과 같은 루프에 붙인다.
### break
- break의 역할은 루프나 switch에서 빠져 나오게 하는 것으로 break키워드 뒤에 레이블 이름이 따라올 수 있다.
<pre><code>break;
break 레이블 이름;</code></pre>
### continue
- continue문은 break문과 유사하지만 루프를 빠져나오지 않고 새로운 시작을 하는점에서 차이가 있다.
<pre><code>continue;
continue 레이블 이름;</code></pre>
- continue문은 while, do/while, for, for/in 루프의 몸체 내부에서만 사용되어야 한다. 그 외 사용시 에러가 발생하며, continue문이 실행되면 루프의 현재 반복을 종료하고 다음 반복을 시작한다. 이때, 루프의 종류에 따라 다르게 실행된다.
- while 루프에서는 루프의 시작부분에 지정된 '표현식' 다시 테스트한다.
- do/while 루프에서는 루프의 끝 부분까지 건너뛴 뒤 루프 조건을 테스트한다.
- for 루프에서는 '증가' 표현식을 평가한 후 '테스트' 표현식을 테스트 하여 다음 반복을 수행할지 여부를 판단한다.
- for/in 루프에서는 다음 차례의 프로퍼티 이름을 루프 시작에서 지정된 변수에 할당 후 루프를 다시 시작한다.
- **while 루프는 루프 조건으로 곧장 귀환하는 반면, for 루프는 일단 '증가' 표현식을 평가한 후 루프 조건으로 귀환한다.**
<pre><code>for(var i = 0; i < data.length; i++){
    //오류를 만나면 반복문을 빠져나와 증가 > 테스트를 거친다.
    if(data[i] == null){
        continue;
    }
    total += data[i];
}</code></pre>
###var
- var문은 명시적으로 하나 또는 그 이상의 변수를 선언하는데 사용된다.
- var문에 의해 생성되는 프로퍼티는 delete 연산자로 삭제될 수 없다.
###function
<pre><code>function 함수명(전달인자1, 전달인자2..){
    문장
}</code></pre>
- 함수정의는 문장이 아닌 구조를 나타낼 뿐이다. 문장은 실행 시간에 실행되는 반면, 함수는 코드가 실행되기 이전의 파싱(parsing) 또는 컴파일 단계에서 정의된다.
###return
- 함수 호출 표현식의 값, 함수에서 반환되는 값을 지정하는데 쓰인다.
<pre><code>return 표현식;
function square(x){ return x*x; }</code></pre>
- 또한, 값을 반환하지 않고 단지 함수의 실행을 종료할 목적으로 "표현식" 없이 return문만 사용할 수 있다.
<pre><code>function display_obj(obj){
    //전달인자가 유효하지 않으면 건너뛴다.
    if(obj == null){
        return;
    }
    문장..
}</code></pre>
- "표현식"이 없는 return문을 실행하거나 함수가 반환되면, 해당 함수 호출 표현식의 값은 undefined가 된다.
###throw
- "예외"란 무언가 예외적인 상황이나 에러가 발생했음을 가리키는 신호이다. throw는 예외상황을 알린다는 것을, catch는 그것을 처리한다는 것을 의미한다.
<pre><code>function factorial(x){
    // 입력 전달 인자가 유효하지 않으면 예외를 발생시킨다.
    if (x < 0) {
        throw new Error('x must not be negative');
    }
    // 유효하면 값을 계산, 반환한다.
    문장
    return f;
}</code></pre>
- 예외가 발생하면 프로그램 실행을 즉시 중단하고 가장 가까운 예외 처리기로 넘어간다. 해당 코드블록이 catch 절과 연결되어 있지 않으면 바로 상위 코드 블록이 catch절과 연결되어 있는지 반복한다. 예외 처리기를 찾을때까지 이 과정을 반복하고 아무런 예외 처리기도 찾을 수 없으면 이 예외는 에러로 취급, 사용자에게 보고된다.
###try/catch/finally
- 자바스크립트의 예외 처리 기법
- try 절은 예외가 발생할지도 모르는 코드 블록을 정의하는 역할을 한다.
- try 블록 다음 이어지는 catch절은 try 블록 내부에서 예외가 발생할 경우 호출되는 문장 블록이다.
- catch 절 다음 이어지는 finally 블록에는 try 블록과 무관하게 항상 실행이 보장되어야 할 뒷정리용 코드도 포함된다.
<pre><code>try{
    //문제가 없을 시 블록의 시작부터 끝까지 수행된다.
    //상황에 따라 예외가 발생할 수 있다. (throw 문에 의한 직접 호출 또는 예외를 발생시키는 메서드의 호출에 의해 발생)
}catch(e){
    //catch 블록은 오직 try 블록에서 예외가 발생한 경우에만 실행
    //이 문장에선 지역 변수 e를 사용하여 Error 객체 또는 다른 값을 참조할 수 있다.
    //예외를 처리할 수도, 무시할 수도, throw를 사용하여 다른 예외를 발생시킬 수도 있다.
}finally{
    //try블록이 종료되면 무조건 실행된다.
    //try블록이 종료되는 상황
    //1.정상적으로 블록의 끝에 도달했을 때
    //2.break, continue 또는 return 문에 의해서
    //3.예외가 발생했지만 앞의 catch 절에서 처리 했을 때
    //4.예외가 발생했고 그것이 잡히지 않은 채 퍼져나갈 때
}</code></pre>
<pre><code>try{
    //사용자에게 입력 요청
    var n = prompt('enter');
    alert(n);
}catch(e){
    //만일 사용자 입력이 유효하지 않으면 catch블록 실행
    //지역변수 e를 참조하여 어떤 에러인지 알린다.
    alert(e);
}</code></pre>
###with
- with문은 유효범위체인을 임시로 변경하려 할 때 쓰인다.
<pre><code>with (객체) {
    문장
}</code></pre>
<pre><code>//html폼에서 어떤 엘리먼트에 접근하려면 아래와 같이 접근한다.
frames[1].document.forms[0].address.value;
//위의 폼을 여러번 접근해야 한다면 with문을 사용하여 유효 범위 체인에 위 폼을 추가하는 것이 편하다.
with(frames[1].document.forms[0]){
    //여기선 폼 엘리먼트에 직접 접근이 가능하다.
    name.value ="";
    address.value ="";
    email.value ="";
}</code></pre>
- 코드 최적화가 어렵고, with문 내부에서 함수 정의나 변수 초기화를 했다면 비직관적이고 예기치 않은 작동을 불러올 수 있기 때문에 **with문 사용은 지양**한다.

---

##객체와 배열
- 객체는 이름 붙은 값들의 집합, 배열은 숫자가 붙은 값들의 순서 있는 집합이다.
- 객체 프로퍼티 값에 접근하기 위해서는 마침표(.) 연산자를 사용한다.
<pre><code>//obj객체의 x프로퍼티를 변수 x에 담는다.
var x = obj.x;</code></pre>
###프로퍼티 존재 확인
- in 연산자를 사용하여 객체 프로퍼티의 존재 여부를 확인할 수 있다.
<pre><code>//객체 obj에 "x"프로퍼티가 있으면 alert()을 실행한다.
if("x" in obj){
    alert();
}</code></pre>
- 하지만 객체에 없는 프로퍼티에 접근하려 하면 undefined 값이 반환되기 때문에 in 연산자보다는 아래와 같이 표현할 수 있다.
<pre><code>if(obj.x !== undefined){
    alert();
}</code></pre>
###프로퍼티 삭제
- 객체의 프로퍼티를 삭제하기 위해서는 delete 연산자를 사용한다.
<pre><code>delete obj.x;</code></pre>
- 객체의 프로퍼티에 접근하기 위해서 마침표(.) 연산자를 사용하는데 [] 연산자를 사용해도 객체의 프로퍼티에 접근할 수 있다.
<pre><code>if(obj.x === obj["x"]) //true</code></pre>
- 마침표 연산자에서는 프로퍼티 이름을 식별자로 지정했지만, [] 연산자에서는 이름을 문자열로 표현했다는 점에서 자바스크립트의 타입 제약의 느슨함, 유연성이 드러난다.
### 공통적으로 나타나는 객체 프로퍼티와 메서드
-






173






























